package cern.molr.commons.web;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import javafx.util.Pair;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.util.Optional;
import java.util.function.Function;

/**
 * A data exchange builder between the client and the server. It builds a publisher of string messages which is
 * generated from one element received from a Flux of strings
 *
 * @author yassine-kr
 */
public class DataExchangeBuilder<Input, Output> {

    /**
     * The mapper used for serializing output and deserializing input
     */
    private ObjectMapper mapper;
    private Class<Input> inputType;
    private Class<Output> outputType;
    private Flux<String> preInput;
    private ThrowingFunction<Input, Flux<Output>> generator;
    private Pair<Function<Throwable, Output>, Function<Throwable, String>> generatorExceptionHandler;
    private Pair<Function<Throwable, Output>, Function<Throwable, String>> generatingExceptionHandler;
    private Pair<Function<Throwable, Output>, Function<Throwable, String>> receivingExceptionHandler;
    public DataExchangeBuilder(Class<Input> inputType, Class<Output> outputType) {
        this.inputType = inputType;
        this.outputType = outputType;

        mapper = new ObjectMapper();
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
    }

    /**
     * Set the received Flux of messages
     *
     * @param preInput received flux of messages
     *
     * @return this builder to chain other methods
     */
    public DataExchangeBuilder<Input, Output> setPreInput(Flux<String> preInput) {
        this.preInput = preInput;
        return this;
    }

    /**
     * Set the generator which generates the output flux from the received input data
     *
     * @param generator
     *
     * @return this builder to chain other methods
     */
    public DataExchangeBuilder<Input, Output> setGenerator(ThrowingFunction<Input, Flux<Output>> generator) {
        this.generator = generator;
        return this;
    }

    /**
     * Set the handler of the exception thrown by the generator
     *
     * @param function1 the returned output will be serialized and wrapped in a publisher of one element
     * @param function2 if the serialization fails, this function is called with the initial exception as parameter
     *
     * @return this builder to chain other methods
     */
    public DataExchangeBuilder<Input, Output> setGeneratorExceptionHandler(Function<Throwable, Output> function1,
                                                                           Function<Throwable, String> function2) {
        this.generatorExceptionHandler = new Pair<>(function1, function2);
        return this;
    }

    /**
     * Set the handler of each serialization exception thrown when serializing output elements published by the
     * flux generated by the generator. The exception passed as parameter is the serialization exception
     *
     * @param function1 the returned output will be serialized in the final publisher instead of the failed element
     * @param function2 if the serialization fails again, use directly the string returned by this function
     *
     * @return this builder to chain other methods
     */
    public DataExchangeBuilder<Input, Output> setGeneratingExceptionHandler(Function<Throwable, Output> function1,
                                                                            Function<Throwable, String> function2) {
        this.generatingExceptionHandler = new Pair<>(function1, function2);
        ;
        return this;
    }

    /**
     * Set the handler of the deserialisation exception thrown when trying to deserialize the input message
     *
     * @param function1 the returned output will be serialized and wrapped in a publisher of one element
     * @param function2 if the serialization fails, this function is called with the deserialization exception as
     *                  parameter
     *
     * @return this builder to chain other methods
     */
    public DataExchangeBuilder<Input, Output> setReceivingExceptionHandler(Function<Throwable, Output> function1,
                                                                           Function<Throwable, String>
                                                                                   function2) {
        this.receivingExceptionHandler = new Pair<>(function1, function2);
        ;
        return this;
    }

    /**
     * builds the publisher
     *
     * @return the publisher
     */
    public Flux<String> build() {
        return preInput.take(1).<Optional<Input>>map((data) -> {
            try {
                return Optional.ofNullable(mapper.readValue(data, inputType));
            } catch (IOException e) {
                e.printStackTrace();
                return Optional.empty();
            }
        }).concatMap((optionalInput) -> {
            if (optionalInput.isPresent()) {
                try {
                    return generator.apply(optionalInput.get()).map((output -> {
                        try {
                            return mapper.writeValueAsString(output);
                        } catch (JsonProcessingException e) {
                            try {
                                return mapper.writeValueAsString(generatingExceptionHandler.getKey().apply(e));
                            } catch (JsonProcessingException e1) {
                                return generatingExceptionHandler.getValue().apply(e);
                            }
                        }
                    }));
                } catch (Exception e) {
                    try {
                        return Mono.just(mapper.writeValueAsString(generatorExceptionHandler.getKey().apply(e)));
                    } catch (JsonProcessingException e1) {
                        return Mono.just(generatorExceptionHandler.getValue().apply(e));
                    }
                }
            } else {
                try {
                    return Mono.just(mapper.writeValueAsString(receivingExceptionHandler.getKey().apply(new
                            Exception("unable to deserialize the input data"))));
                } catch (JsonProcessingException e1) {
                    return Mono.just(receivingExceptionHandler.getValue().apply(new
                            Exception("unable to deserialize the input data")));
                }
            }
        });
    }

    /**
     * A function which can throws an exception
     *
     * @param <T> parameter type
     * @param <R> return type
     */
    @FunctionalInterface
    public interface ThrowingFunction<T, R> {
        R apply(T t) throws Exception;
    }


}